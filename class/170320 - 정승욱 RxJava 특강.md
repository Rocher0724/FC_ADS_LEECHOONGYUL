package com.nobrain.rx_study.step1;

import android.os.Bundle;
import android.support.v7.app.AppCompatActivity;
import android.util.Log;
import android.widget.TextView;

import java.util.Arrays;
import java.util.List;

import io.reactivex.Observable;
import io.reactivex.android.schedulers.AndroidSchedulers;
import io.reactivex.functions.Consumer;
import io.reactivex.functions.Function;
import io.reactivex.schedulers.Schedulers;
import io.reactivex.subjects.PublishSubject;

public class MainActivity extends AppCompatActivity {

    private TextView tv;
    PublishSubject<Integer> subject;
    private int data = 0;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        tv = (TextView) findViewById(R.id.tv_main);
        findViewById(R.id.button).setOnClickListener($ -> {
            subject.onNext(data++);
        });

        /*
         * 1,2,3,4,5,6,... 을
         * a,b,c,d,e,f,... 으로 바꿀거임
         */
        List<Integer> datas = Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14);
        subject = PublishSubject.create();
        subject
                .observeOn(Schedulers.computation()) // 주로 computation스레드(연산)와 io스레드(입출력)만 사용함.
                .map(data -> {
                    Log.d("RxJava", "map : " + Thread.currentThread().getName());
                    if(data % 2 == 1) {
                        return ' ';
                    }
                    return ((char) ('a' + data));
                })
                .observeOn(AndroidSchedulers.mainThread())
                .subscribeOn(Schedulers.io())
                .subscribe(character -> {
                    Log.d("RxJava", "map : " + Thread.currentThread().getName());
                    tv.setText(tv.getText().toString() + character);
                });
    }

    @Override
    protected void onDestroy() {
        if(subject != null) {
            subject.onComplete(); // 메모리관리를 위해 설정
        }
        super.onDestroy();

    }
}




위에것을 보면 필드에 int 97이 선언되어있는게 불편하다고 하신다.
조금 수정해보자
----------------------------------------------------------------------------------
package com.nobrain.rx_study.step1;

import android.os.Bundle;
import android.support.v7.app.AppCompatActivity;
import android.util.Log;
import android.widget.TextView;

import java.util.Arrays;
import java.util.List;

import io.reactivex.Observable;
import io.reactivex.android.schedulers.AndroidSchedulers;
import io.reactivex.functions.Consumer;
import io.reactivex.functions.Function;
import io.reactivex.schedulers.Schedulers;
import io.reactivex.subjects.BehaviorSubject;
import io.reactivex.subjects.PublishSubject;

public class MainActivity extends AppCompatActivity {

    private TextView tv;
    BehaviorSubject<Integer> subject;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        tv = (TextView) findViewById(R.id.tv_main);
        findViewById(R.id.button).setOnClickListener($ -> {
            subject.onNext(subject.getValue() + 1);
        });

        /*
         * 1,2,3,4,5,6,... 을
         * a,b,c,d,e,f,... 으로 바꿀거임
         */
        List<Integer> datas = Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14);
        subject = BehaviorSubject.createDefault (0);
        subject
                .observeOn(Schedulers.computation()) // 주로 computation스레드(연산)와 io스레드(입출력)만 사용함.
                .map(data -> {
                    Log.d("RxJava", "map : " + Thread.currentThread().getName());
                    if(data % 2 == 1) {
                        return ' ';
                    }
                    return ((char) ('a' + data));
                })
                .observeOn(AndroidSchedulers.mainThread())
                .subscribeOn(Schedulers.io())
                .subscribe(character -> {
                    Log.d("RxJava", "map : " + Thread.currentThread().getName());
                    tv.setText(tv.getText().toString() + character);
                });
    }

    @Override
    protected void onDestroy() {
        if(subject != null) {
            subject.onComplete(); // 메모리관리를 위해 설정
        }
        super.onDestroy();

    }
}


----
수정된 사항은 비헤이비어를 선언해서 디폴트 값으로 숫자를 지정해주었다.


포문을 바꾸는것부터 시작해서 리스트, 서브젝트 등의 것들로 응용해나가면 좋다.