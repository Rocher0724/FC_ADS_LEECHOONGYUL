# Java
1. 객체, 클래스, 인스턴스 차이점
 - 객체 : 데이터와 그에 관련되는 동작을 포함해서 나타낼 수 있는 최소 설계단위. 단위객체의 사이즈가 작을수록 재사용성이 좋을 수 있다.(물론 설계를 잘해야 말이겠지만...)
 - 클래스 : 객체를 기계가 읽을 수 있는 코드의 전단계로 구현한 구현체
 - 인스턴스 : 클래스를 메모리에 적재하여 사용할수 있는 것
2. 인터페이스, 추상객체 차이점
 - 인터페이스 : 기능의 이름만 정의된 설계도 개념으로, 개발자로 하여금 해당 기능을 구현하도록 강제할 수 있다.
             인터페이스는 이름만 가질 뿐 코드를 가질 수 없다. implements 를 통한 구현
 - 추상객체 : 코드와 함께 저장소가 구현된 설계 객체. extends 를 통한 구현
3. 본인이 공부한 디자인패턴 
 - 모르는걸 찝어서 물어보면 이름에서 연상해 내거나, 
   아직 해당 디자인 패턴은 공부하지 않았지만, 지금 질문하신 패턴외에 이러저러한 패턴을 공부했고 거기에 대한 설명은 가능하다.(물론 본인이 설명 가능한 부분만 하셔야 되겠지요)
 - 그래도 기본으로 ‘생성,구조,행위로 구분할 수 있는 객체지향 설계패턴 모음집 입니다’ 라고 말할수는 있어야 합니다.
    ##생성 (Creational) - 인스턴스 생성을 위한 패턴으로 객체와 생성된 인스턴스 사이의 의존성을 제거해준다.
    1. Abstract factory    : 인스턴스화 할 패토리에 대한 결정을 중앙 집중화 함
    2. Factory method      : 여러 개의 구현 중에 특정 타입의 객체를 선택 생성하는 작업을 중앙 집중화함
    3. Builder     : 생성 절차는 동일하나 서로 다른 결과를 가져오는 경우, 복잡한 객체의 구축을 표현(represention)과 분리함
    4. Lazy initialization : 객체 생성, 값 계산, 다른 값 비싼 프로세스를 실제로 필요한 시점까지 지연하는 전술
    5. Object pool    : 더이상 사용하지 않는 객체의 재활용을 통해 값 비싼 획득 및 해지를 피함
    6. Prototype pattern   : 어떤 애플리케이션에서 표준적인 객체 생성이 값비쌀 때 사용함
    7. Singleton pattern   : 클래스의 객체 생성을 하나로 제한함
    ##구조 (Structural) - 클래스 및 객체들을 구성을 통해서 더 큰 구조로 만들 수 있게 해준다
    1. Adapter       : 어떤 클래스를 위해, 클라이언트가 기대하는 하나의 인터페이스를 채택함
    2. Bridge        : 추상적인 부분을 구현과 분리함으로써 두 요소가 독립적으로 확장 가능하게 함
    3. Composite     : 각 객체가 동일한 인터페이스를 가지는 객체들의 트리구조
    4. Decorator     : 상속을 사용할 경우 클래스 갯수가 지수적으로 늘어날 경우, 클래스에 기능 추가
    5. Facade       :  기존의 복잡한 인터페이스들을 사용하기 쉽도록 단순화한 인터페이스 생성
    6. Flyweight     : 공간을 절약하기 위해 공통의 속성을 공유하는 많은 수의 객체
    7. Proxy       : 다른 것들을 위한 인터페이스 역할을 하는 클래스
    ##행위 (Behavioral) - 클래스와 객체들이 상호작용하는 방법 및 역할을 분담하는 방법을 정의한다
    1. Chain of responsibility :  명령 객체가 로직을 포함하고 처리하는 객체에 의해 다른 객체로 전달되거나 처리됨
    2. Command     :  행위와 매개변수를 포함하고 있는 명령 객체
    3. Interpreter    : 특정 문제 집합을 신속하게 풀기 위해 특수화된 컴퓨터 언어를 구현함
    4. Iterator     : 객체 내부 표현방식을 노출하지 않고 집합 객체의 요소에 순차적으로 접근할 때 사용함
    5. Mediator    : 하위 시스템 안에서 인터페이스의 집합을 위하여 통합된 인터페이스를 제공
    6. Memento    : 객체를 이전의 상태로 되돌릴 수 있는 역량을 제공함 (Rollback)
    7. Null Object     : 객체의 기본값(default value)으로 작동하도록 설계함
    8. Observer    : 별칭 : Publish/Subscribe 또는 이벤트 리스너; 다른 객체에 의해서 발생할 이벤트를 관찰하기 위해 객체를 등록
    9. State     : 실행 시점에 알고리즘을 선택할 수 있도록 함
    10.Specification     : 부울리언 방식으로 재결합할 수 있는 비즈니스 로직
    11.Template method    : 프로그램의 뼈대를 기술함으로써 처리 절차를 공유함
    12.Visitor    : 객체로부터 알고리즘을 분리하는 방법
4. 자바의 메모리구조
    이건 그림으로 찾아보는게 좋을듯 하군요
    Method(Static) - 실제 실행 코드가 올라가는 영역
    Heap - new 연산자를 통해 instance화 되는 공간 (가비지콜렉션 대상) = Eden : Survivor : Old 로 나뉨 - Permanent 가 있었으나 JDK 8부터 없어짐
    Stack - 
    PC Register - 현재 실행되는 JVM의 명령어 주소
    Native Method Stack - 
5. 자료구조 (이건 알아서들...) - array, list, Linked_list, 등 
6. Process, Thread
    Process : 프로그램당 한개 생성
    Thread : 프로그램당 여러개 생성
7. JDK 와 OpenJDK의 차이점 (기술적 트렌드에 대한 민감도가 있는 회사라면... 이정도 질문은 할듯)
    크게 차이는 없는것으로 알고 있지만 SSL 통신에 있어서 간헐적인 오류가 보고된 적은 있습니다.
# Android
1. Dalvik, ART
    Dalvik - JIT를 통한 실행직전 한번의 컴파일과정 필요. 런타임시 과도한 부하가 발생하는 부담있음
    ART - AOT를 통해 설치시 한번의 컴파일과정 필요. 런타임시 부하는 줄였으나 모바일기기라는 한정된 공간에 설치공간이 부족해지는 문제점 있음
    24버전 ART 부터는 JIT 와 AOT 를 함께 사용함
2. Thread, Handler, Looper
    - Thread : 프로그램이 동작하는 최소단위이나 프로그램내에서 독립적인 메모리 공간을 사용하기 때문에 공유되지는 않는다
    - Handler : 따라서 Thread간의 통신을 위해서 Handler를 사용하면 Thread간 메시지를 주고받을 수 있다.
    - Looper : Activity에 존재하는 기본적인 메시지 전달 객체이다. Handler로 전송되는 메시지는 큐에 쌓이게 되는데 Looper는 이 메시지를 꺼내서 목적하는 Handler로 전달하게 된다.
3. AsyncTask, Reactive, Retrofit, OKHTTP
    - AsyncTask : 메인 Thread로 부터 비동기 처리를 위해 안드로이드에서 제공하는 클래스. 
    - Reactive : 작업이 화면상의 지연 없이 동작하도록 화면과 데이터를 분리하여 처리할 수 있게 해주는 함수형 언어 라이브러리. 대표적으로 MVVM 아키텍처를 RX로 만들수 있는데 뷰에 변경사항이 있으면 실시간으로 모델을 갱신해 줄 수 있다. (여러분이 공부하신거 중에는 RXBinding 이 가장 대표적이겠군요. 입력할때마다 처리해주는...)
    - Retrofit : 역시 메인 Thread로 부터 비동기 처리를 지원하는 외부라이브러리. 인터페이스를 통해 RESTFul의 구현이 용이하고 OkHttp 와 연동으로 인증처리 또한 구조적으로 해결할 수 있다. AsyncTask에 비해 최소 3배 이상의 성능향상을 보인다. (출처:http://instructure.github.io)
    - OKHttp : 인증등의 네트워킹을 처리를 도와주는 라이브러리. 하지만 동일 Thread 내에서 처리되기 때문에 Thread를 생성하는 외부처리가 필요하다.
4. Activity, Fragment 생명주기
    Activity :          create >                               start > resume > running > pause > stop >               destroy
    Fragment : attach > create > createView > activityCreate > start > resume > running > pause > stop > destroyView > destroy > detach
    (Activity를 주로 암기하시고 Fragment 는 중복 되는 부분을 중점으로 보고 앞뒤로 attach detach 가 있다는 정도로 설명할 수 있으면 됩니다.)
5. 명시적, 암시적 인텐트
    명시적 : intent = new Intent(MainActivity.this, SubActivity.class); // 호출할 클래스명을 특정해주는것
    암시적 : intent = new Intent(android.content.Intent.ACTION_SEND); // 클래스명이 아닌 시스템에 이미 정의된 플래그를 호출하는것
6. Content Provider, Resolver
    Provider : 서로다른 어플리케이션간에 데이터를 공유하기 위한 제공자측 인터페이스
    Resolver : 사용자측 인터페이스
7. 이미지 다운로드시 메모리 overflow 처리
  ‘Glide 쓰면 됩니다‘’ 라고 하면 안됩니다. 그건 가장 마지막에 부연 정도로 이런이런 라이브러리가 있다 라고 해야 됩니다.
  현재 네트웍 기술은 웹이 가장 정형화 되어 있는데 웹서버를 구성하는 몇몇 라이브러리를 보면, 
  이미지를 저장할 때 화면 사이즈에 따라 많게는 9개정도의 사이즈로 저장을 한다.
  가. 그래서 서버와의 협업을 통해 일단 1차적으로 화면에 출력되는 실 사이즈를 토대로 클라이언트 기기에 맞게 최적화 하고,
  나. 목록이라면 이미지가 뿌려지는 뷰를 리사이클링하는 형태로 처리할 수 있을것 같습니다.
     ? 여기서 라이브러리 없이 리사이클링 하겠다고 했는데 어떻게 구현할거냐고 물어본다면 (당연히 물어봐야 정상)
       > 이론적으로는 화면사이즈에 맞는 개수만큼만 이미지 뷰를 생성하고, 
         화면사이즈를 넘어가는 이미지뷰 요청이 있으면 화면 사이즈를 벗어난 뷰로 대체하는 방식을 사용할 수 있는데,
         일반 ListView에서는 holder 형태로 구현할 수 있고 RecyclerView 는 기본적으로 지원합니다.
# Algorithm
1. 만약 알고리즘이 나오다면 뻔하게 한문제가 나올겁니다. 모두 같은 문제인데 이런식으로...
    가. 1 부터 n까지 더하는 알고리즘 
        (n+1)*n/2
    나. 1 부터 n까지 숫자중에 빠진 숫자 찾기
        전부 더한다음에 위의 결과값에서 빼주면 됩니다. XOR도 있긴 한데 복잡도가 동일합니다. (이렇게 답변할 수 있다면 당신은 이미 프로그래머 ㅡㅡ/)
    다. n ~ m 까지 더하는 알고리즘
        (m+1)*m/2 - (n-1)*n/2 (시작하는 n은 제외해야됨)
    라. 1부터 100까지 짝수 합
        a.패턴파악
        (2+100) + (4+98) + (6 +96) .. 보이심? 100까지 102인 숫자가 50번 더해지겠죠?
        b. (100+2)*(100/2)/2
    마. 진화형 1부터 n까지 짝수 합
        - if문으로 n이 짝수인지를 확인한 후 위의 처리한다.
2. 피보나치
    재귀를 하셔도 되고... 걍 반복문 돌리셔도 될듯
3. 아나그램
    이건 정렬하시면 되죠
# 포트폴리오 
1. 사용한 아키텍처
    MVC, MVP, MVVM 등 본인이 사용하고자 했던 아키텍처에 대한 설명을 하시고 
    어느정도까지 구현됬고 아쉬운 점은 어떤건데, 
    시간이 있다면 이러이러하게 좀더 구체화 해보고 싶습니다.
    (마지막 줄이 중요한데 문제에 대한 해결책을 꼭 제시하셔야 합니다.)
2. 예외처리
    일반적인 Exception 처리를 했고, 
    사용자가 설치후 발생할 수 있는 오류에 대해서는 일단 Firebase 에서 지원하는 Crash 툴을 이용해서 실시간으로 모니터링 할 수 있게 구성했습니다.
    (물론 한사람이 몇명 없을듯...)
    그리고 Firebase 로그처리의 단점은 오류가 발생한곳이 예외처리 된곳으로 한정되기 때문에
    차후에는 트위터의 fabric이나 ...
3. 테스트 
    단위테스트로는 개별 화면단위로 JUnit을 적용했고 통합테스트로는 Github를 통해 Travis를 사용해 보았습니다.
4. 코드컨벤션
    Java Code Convention 관련은 2016년 현재 가장 현행화 되어있는 Google의 Java Style Guide 를 최대한 반영하였지만,
    사이트는 여기 >> https://google.github.io/styleguide/javaguide.html
    몇가지 가독성이 저랑 안맞는 부분은 임의로 변경하였습니다. 
    변경된 부분은 함수 코딩에 있어 () 괄호 다음에 시작되는 { 중괄호가 한칸 띄도록 되어있는데 붙이는게 눈에 더 들어와서 붙여서 코딩했습니다.
    이부분은 회사 표준에 맞게 따르도록 하겠습니다. 
    (마지막줄 중요...)
5. 사용한 라이브러리 설명
    다들 비슷한거 쓰셨을 테니 각자 공유들 하심이...
6. 사용이유?
    역시 비슷한거 쓰셨을 테니 각자 공유들 하심이...
7. 라이브러리 없이 구현가능한 부분에 대한 설명
    - 이건 위의 이미지 오버플로우 관련과 비슷하게 답할 수 있으면 됩니다.
# 방법론
여러분이 하신 애자일과 스크럼을 잘 설명하시면 되구요. 
TDD로 그날 그날 테스트를 하고 집으로 갔다라고... (거짓말을... 쿨럭 ㅡ,.ㅡ;;;)


오브젝트 클래스 인스턴스 차이 

앱스트랙트랑 인터페이스
인터페이스 : 설계 명세 , 메소드만 강제 
앱스트랙트 : 코드까지 강제 

정렬 에 ㄷ해서 아는것. 이야기해보세용 

의존성주입 

RDB와 NOSQL

user1객체와 user2객체가 같은 객체인지 알려면 어떻게 해야할까요? 주소값을 비교한다( == 은 주소값을 비교)

