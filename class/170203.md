public class MainActivity extends AppCompatActivity  버전호환성을 위해서 맵 컴펫 액티비티를 사용한다.


태블릿에서 UI가 변경되는걸 방지하기 위해서 values와 values-w820dp 폴더의 dimens.xml 파일 변경함.


제너릭  
사용이유 
	타입안정성:단일타입의 오브젝트만 저장 
	타입캐스팅 제거:저장된 오브젝트에 대한 타입캐스팅이 필요없음  
	컴파일시 에러에 대한 선확인: 타입캐스팅 등 에러에 대한 옟ㄱ이 가능해 지므로 실행하기 전 컴파일 타임에 에러를 발생시킬 수 있다.  

일반적 정의방법 
	Type T
	Element E
	Key K
	Number N
	Value V

``` java

	public static <E> void printArray(E[] elements) {
		for( E element : elements) {
			System.out.println(element);
		}
	}

```
	제너릭 요소 사이에는 타입 호환성(다성성)이 존재하지 않는다. 예를들어 integer가 numver와 같다고 해도 class<Integer> 가 class <Number> 는 아니다.

```
	ArrayList<Triangle> shapeList = new ArrayList<>();
		
		shapeList.add(tri1);
		shapeList.add(tri2);
		shapeList.add(tri3);
		
		draw(shapeList);
		
	}
	
	// 함수에서 와일드 카드 사용하기 
	// 상단에서 제너릭으로 Triangle을 넣었기 때문에 하단에 List<Triangle> 이 들어가야 맞지만
	// List<? extends Shape> 를 통해서 Shape를 상속받은 친구들은 전부 사용할수 있도록 만들어 준 것이다.
	public static void draw(List<? extends Shape> lists) {
		for ( Shape s : lists ) {
			s.drawShape();
		}
	}
```

객체지향 프로그래밍 





애너테이션 annotation
	컴파일러에 정보제공 : @Override 같은것 
	실행간에 특수기능 제공 : @Transaction
	코드 자동생성 : @컴파일과정에 어노테이션 정보를 통해 필요한 코드를 자동으로 생성한다.
Annotation.java
```

import static java.lang.annotation.ElementType.TYPE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

import java.lang.annotation.Retention;
import java.lang.annotation.Target;

@Retention(RUNTIME)
@Target(TYPE)
public @interface Annotation {
	public String val() default "값";
	public String key();
}

```

main.java
```
public class Main {
	public static void main(String[] args) {
		
		ForAnno anno = new ForAnno();
		String anno_val = anno.getClass().getAnnotation(Annotation.class).val();
		String anno_key = anno.getClass().getAnnotation(Annotation.class).key();
		
		System.out.println("anno_key=" + anno_key + ", anno_val = " +anno_val);
	}

@Annotation(key = "xxxx")
class ForAnno {
	
}
```

출력값 
> - anno_key=xxxx, anno_val = 값

---

